ScriptName _LEARN_ControlScript extends Quest ; conditional
; This script is the mod's main script. It is attached to the player
; via an alias in the mod's quest, and it is reponsible for managing the spell list
; and initializing the mod's variables and functions on first runs and upgrades.
; Since it is attached to the player via the quest, any events reported by the engine
; which are generated by the player can also be handled here, such as OnSleep, OnCast, etc.

GlobalVariable property _LEARN_CountAlteration auto
GlobalVariable property _LEARN_CountConjuration auto
GlobalVariable property _LEARN_CountDestruction auto
GlobalVariable property _LEARN_CountIllusion auto
GlobalVariable property _LEARN_CountRestoration auto
GlobalVariable property _LEARN_CountBonus auto
GlobalVariable property _LEARN_MinChanceStudy auto
GlobalVariable property _LEARN_MaxChanceStudy auto
GlobalVariable property _LEARN_MinChanceDiscover auto
GlobalVariable property _LEARN_MaxChanceDiscover auto
GlobalVariable property _LEARN_BonusScale auto
GlobalVariable property _LEARN_MaxFailsBeforeCycle auto
GlobalVariable property _LEARN_RemoveSpellBooks auto
GlobalVariable property _LEARN_CollectNotes auto
GlobalVariable property _LEARN_ForceDiscoverSchool auto
GlobalVariable property _LEARN_StudyInterval auto
GlobalVariable property _LEARN_AutoNoviceLearningEnabled auto
GlobalVariable property _LEARN_AutoNoviceLearning auto
GlobalVariable property _LEARN_ParallelLearning auto
GlobalVariable property _LEARN_HarderParallel auto
GlobalVariable property _LEARN_DreadstareLethality auto
GlobalVariable property _LEARN_EffortScaling auto
GlobalVariable property _LEARN_AutoSuccessBypassesLimit auto
GlobalVariable property _LEARN_TooDifficultEnabled auto
GlobalVariable property _LEARN_TooDifficultDelta auto
GlobalVariable property _LEARN_SpawnItems auto
GlobalVariable property _LEARN_PotionBypass auto
GlobalVariable property _LEARN_IntervalCDR auto
GlobalVariable property _LEARN_IntervalCDREnabled auto
GlobalVariable property _LEARN_MaxFailsAutoSucceeds auto
GlobalVariable property _LEARN_DynamicDifficulty auto
GlobalVariable property _LEARN_ConsecutiveDreadmilk auto
GlobalVariable property _LEARN_LastSetHome auto
GlobalVariable property _LEARN_LastDayStudied auto
GlobalVariable property _LEARN_AlreadyUsedTutor auto
GlobalVariable property _LEARN_DiscoverOnSleep auto
GlobalVariable property _LEARN_LearnOnSleep auto
GlobalVariable property _LEARN_maxNotes auto
GlobalVariable property _LEARN_maxNotesBonus auto
GlobalVariable property _LEARN_ReturnTomes auto
GlobalVariable property _LEARN_ResearchSpells auto
GlobalVariable property _LEARN_RemoveUnknownOnly auto
String[] effortLabels

ObjectReference QASpellTomeContainer
; Odin
ObjectReference ODN_Conjuration_Chest
ObjectReference ODN_Illusion_Chest
ObjectReference ODN_Restoration_Chest
ObjectReference ODN_Destruction_Chest
ObjectReference ODN_Alteration_Chest
; Apocalypse
ObjectReference WB_Conjuration_Chest
ObjectReference WB_Illusion_Chest
ObjectReference WB_Restoration_Chest
ObjectReference WB_Destruction_Chest
ObjectReference WB_Alteration_Chest
; Spell Learning chest
ObjectReference property _LEARN_DiscoveryChest auto

GlobalVariable property _LEARN_EnthirSells auto
_LEARN_enthirChestAlias property enthirChestAlias auto
_LEARN_tolfdirChestAlias property tolfdirChestAlias auto

Keyword property LocTypeTemple auto
Location property WinterholdCollegeLocation auto
Keyword property LocTypePlayerHouse auto
Keyword property LocTypeInn auto
Location property customLocation auto

Actor property PlayerRef auto
GlobalVariable property GameHour auto
GlobalVariable property GameDaysPassed auto
Book property _LEARN_SpellNotesAlteration auto
Book property _LEARN_SpellNotesConjuration auto
Book property _LEARN_SpellNotesDestruction auto
Book property _LEARN_SpellNotesIllusion auto
Book property _LEARN_SpellNotesRestoration auto
Book property _LEARN_SpellNotesGeneric auto
MagicEffect Property AlchDreadmilkEffect auto
MagicEffect Property AlchShadowmilkEffect auto
MagicEffect Property _LEARN_PracticeEffect auto
Spell Property _LEARN_DiseaseDreadmilk auto
Spell property _LEARN_PracticeAbility auto
Spell property _LEARN_SummonSpiritTutor auto
Spell property _LEARN_SetHomeSp auto
Spell property _LEARN_StudyPower auto
Spell property _LEARN_SpellsToLearn auto
Book property _LEARN_SpellTomeSummonSpiritTutor auto
Book property _LEARN_SetHomeSpBook auto

LeveledItem property LitemSpellTomes00Alteration auto
LeveledItem property LitemSpellTomes00Conjuration auto
LeveledItem property LitemSpellTomes00Destruction auto
LeveledItem property LitemSpellTomes00Illusion auto
LeveledItem property LitemSpellTomes00Restoration auto
LeveledItem property LitemSpellTomes25Alteration auto
LeveledItem property LitemSpellTomes25Conjuration auto
LeveledItem property LitemSpellTomes25Destruction auto
LeveledItem property LitemSpellTomes25Illusion auto
LeveledItem property LitemSpellTomes25Restoration auto
LeveledItem property LitemSpellTomes50Alteration auto
LeveledItem property LitemSpellTomes50Conjuration auto
LeveledItem property LitemSpellTomes50Destruction auto
LeveledItem property LitemSpellTomes50Illusion auto
LeveledItem property LitemSpellTomes50Restoration auto
LeveledItem property LitemSpellTomes75Alteration auto
LeveledItem property LitemSpellTomes75Conjuration auto
LeveledItem property LitemSpellTomes75Destruction auto
LeveledItem property LitemSpellTomes75Illusion auto
LeveledItem property LitemSpellTomes75Restoration auto
LeveledItem property LootWarlockRandom auto
LeveledItem property LootRandomBanditWizard auto
LeveledItem property LootForswornRandomWizard auto
LeveledItem property LootLearningDrugs auto
LeveledItem property LootWarlockSpellTomes00All15 auto

Float LastLearnTime
Float LastDiscoverTime
Float LastSleepTime
int iFailuresToLearn
String[] aSchools

LeveledItem[] aAlterationLL
LeveledItem[] aConjurationLL
LeveledItem[] aDestructionLL
LeveledItem[] aIllusionLL
LeveledItem[] aRestorationLL
LeveledItem[] aInventSpellsPtr

int currentVersion; save active version
FormList property _LEARN_removedTomes auto
FormList property _LEARN_alreadyLearned auto
FormList property _LEARN_learningList auto
FormList property _LEARN_discoveryPossibilities auto

bool property CanUseLocalizationLib = false auto;
int property LIST_HEAD_SPARE_COUNT = 8 autoReadOnly
int property LIST_PURGE_AFTER = 31 autoReadOnly
string property SPELL_SCHOOL_ALTERATION = "Alteration" autoReadOnly
string property SPELL_SCHOOL_CONJURATION = "Conjuration" autoReadOnly
string property SPELL_SCHOOL_DESTRUCTION = "Destruction" autoReadOnly
string property SPELL_SCHOOL_ILLUSION = "Illusion" autoReadOnly
string property SPELL_SCHOOL_RESTORATION = "Restoration" autoReadOnly

int property NOTIFICATION_REMOVE_BOOK = 0 autoReadOnly
int property NOTIFICATION_ADD_SPELL_NOTE = 1 autoReadOnly
int property NOTIFICATION_ADD_SPELL_LIST = 2 autoReadOnly
int property NOTIFICATION_ADD_SPELL_LIST_FAIL = 3 autoReadOnly
int property NOTIFICATION_LEARN_SPELL = 4 autoReadOnly
int property NOTIFICATION_LEARN_FAIL = 5 autoReadOnly
int property NOTIFICATION_MOVING_ON = 6 autoReadOnly
int property NOTIFICATION_DISCOVERY = 7 autoReadOnly
int property NOTIFICATION_DREADMILK = 8 autoReadOnly
int property NOTIFICATION_DREAM = 9 autoReadOnly
int property NOTIFICATION_STUDY = 10 autoReadOnly
int property NOTIFICATION_SPIRIT_TUTOR = 11 autoReadOnly
int property NOTIFICATION_TOO_SOON = 12 autoReadOnly
int property NOTIFICATION_ERROR = 13 autoReadOnly
int property NOTIFICATION_VANILLA_ADD_SPELL = 14 autoReadOnly
int property NOTIFICATION_FORCE_DISPLAY = 15 autoReadOnly
int[] property VisibleNotifications Auto Hidden

; === MCM helper functions
String[] function getEffortLabels()
	return effortLabels
endFunction

String[] function getSchools()
    return aSchools
EndFunction

bool function ToggleNotification(int id)
    if id < 0 || id > VisibleNotifications.Length
        return false
    endIf
    int v = 0;
    if VisibleNotifications[id] == 0
        v = 1
    endIf

    VisibleNotifications[id] = v
    return v as bool
endFunction

bool function EnableNotification(int id, bool v)
    if id < 0 || id > VisibleNotifications.Length
        return false
    endIf

    VisibleNotifications[id] = v as int
    return v
endFunction

function notify(String msg, int controlIndex)
    if (VisibleNotifications[controlIndex])
        Debug.Notification(msg)
    endIf
endFunction

; === Tome management
float function takeNotes(Book tome)
    ; For no-SKSE case: generate generic notes because we cannot programatically get spell school, level, or basically
    ; any information at all out of the book. Keep up to 2/3 value depending on overall skill.
    float value = 1
    value = tome.GetGoldValue()*(getAverageSkill()/100*(2/3))
    PlayerRef.addItem(_LEARN_SpellNotesGeneric, value as int, !VisibleNotifications[NOTIFICATION_ADD_SPELL_NOTE])
    ; Return the value of the created notes in case we want to notify some other way
    return value
endFunction

bool function isSpellBook(Book toCheck)
    if (_LEARN_DiscoveryChest.GetItemCount(toCheck) > 0)
        return true
    Else
        return false
    EndIf
    ;;;if (QASpellTomeContainer.GetItemCount(toCheck) != 0)
    ;;;    return true
    ;;;elseIf (WB_Conjuration_Chest.GetItemCount(toCheck) != 0 || WB_Illusion_Chest.GetItemCount(toCheck) != 0 || WB_Restoration_Chest.GetItemCount(toCheck) != 0 || WB_Destruction_Chest.GetItemCount(toCheck) != 0 || WB_Alteration_Chest.GetItemCount(toCheck) != 0)
    ;;;    return true
    ;;;elseIf (ODN_Conjuration_Chest.GetItemCount(toCheck) != 0 || ODN_Illusion_Chest.GetItemCount(toCheck) != 0 || ODN_Restoration_Chest.GetItemCount(toCheck) != 0 || ODN_Destruction_Chest.GetItemCount(toCheck) != 0 || ODN_Alteration_Chest.GetItemCount(toCheck) != 0)
    ;;;    return true
    ;;;else
    ;;;    return false
    ;;;endIf
endFunction

function addTomeToLearningList(Book newTome)
    if (_LEARN_learningList.Find(newTome) == -1)
        _LEARN_learningList.AddForm(newTome)
    endIf
endFunction

function addTomeToRemovedList(Book newTome)
    ; Add the passed tome to the list of tomes we've
    ; removed if it isn't in the list
    if (_LEARN_removedTomes.Find(newTome) == -1)
        _LEARN_removedTomes.AddForm(newTome)
    endIf
endFunction

bool function onLearningList(Book toCheck)
    if (_LEARN_learningList.Find(toCheck) == -1)
        return false
    else
        return true
    endIf
endFunction

bool function alreadyLearned(Book toCheck)
    if (_LEARN_alreadyLearned.Find(toCheck) == -1)
        return false
    else
        return true
    endIf
endFunction

function removeTomeFromLists(Book toRemove)
    _LEARN_learningList.RemoveAddedForm(toRemove)
    _LEARN_removedTomes.RemoveAddedForm(toRemove)
endFunction

function returnTomeAndPurge(Book toReturn)
    ; Look for a tome in the list that has the passed spell
    int index = _LEARN_removedTomes.Find(toReturn)
    if (index != -1)
        ; If we find the right tome in the list, add it to player inventory.
        PlayerRef.AddItem(toReturn, 1, true)
        removeTomeFromLists(toReturn)
        return
    endIf
    ; If we don't find it print a warning to papyrus log. This could be for lots of reasons and isn't necessarily something to worry about.
    Debug.trace("[Spell Learning] Warning: Cannot return tome for learned spell, not in list of removed tomes. This could be because the spell was added to the list with an earlier version of the mod, because the option to remove tomes is off but the option to return tomes has been turned on, or simply because the spell was discovered instead of read.")
endFunction

function TryAddSpellBook(Book akBook, int aiItemCount)
    float value = 0
    ; if option to leave known spell tomes alone is on and the player knows the spell,
    ; do absolutely nothing
    if ((_LEARN_RemoveUnknownOnly.GetValue()) && _LEARN_alreadyLearned.Find(akBook) != -1)
        return
    endIf
    ; remove book
    if (_LEARN_RemoveSpellBooks.GetValue())
        PlayerRef.removeItem(akBook, aiItemCount, !VisibleNotifications[NOTIFICATION_REMOVE_BOOK])
        ; add tome to list of removed tomes
        addTomeToRemovedList(akBook)
    EndIf
	; maybe add notes if we removed the book
    if (_LEARN_CollectNotes.GetValue() && _LEARN_RemoveSpellBooks.GetValue())
        value = takeNotes(akBook)
    endIf
    
    if (onLearningList(akBook))
        if ((_LEARN_CollectNotes.GetValue()) && !(VisibleNotifications[NOTIFICATION_ADD_SPELL_NOTE]) && (_LEARN_RemoveSpellBooks.GetValue()))
            ; Notify with additional note information if vanilla note notifications are off
            notify(__l("notification_spell_not_added_studying_notes_no_skse", "Already studying that spell. Tome deconstructed into notes."), NOTIFICATION_ADD_SPELL_LIST_FAIL)
        else
            ; We don't check if spell learning is on here, but we do below. This is because we need to notify when the player buys a tome for a spell they are currently discovering even if learning is off.
            notify(__l("notification_spell_not_added_studying_no_skse", "Already studying that spell."), NOTIFICATION_ADD_SPELL_LIST_FAIL)
        endIf
    endIf

    if (_LEARN_ResearchSpells.GetValue())
        ; add spell to the todo list if not already known or in list
        if (!alreadyLearned(akBook) && !onLearningList(akBook))
            addTomeToLearningList(akBook)
            if (_LEARN_CollectNotes.GetValue() && (!VisibleNotifications[NOTIFICATION_ADD_SPELL_NOTE]) && (_LEARN_RemoveSpellBooks.GetValue()))
                ; Notify with additional note information if vanilla note notifications are off
                notify(__l("notification_spell_added_notes_no_skse", "Spell added to study list. Tome deconstructed into notes."), NOTIFICATION_ADD_SPELL_LIST)
            else
                notify(__l("notification_spell_added_no_skse", "Added spell to study list."), NOTIFICATION_ADD_SPELL_LIST)
            endIf
        endIf
    endIf
endFunction 

; === Version and upgrade management
int function GetVersion()
    return 177; v 1.7.7
endFunction

function UpgradeVersion()
    bool displayedUpgradeNotice = false
    if (currentVersion < 177)
        string msg = "[Spell Learning] Installed version 1.7.7"
		if (!displayedUpgradeNotice)
			; don't display multiple upgrade messages
			Debug.Notification(msg)
			displayedUpgradeNotice = true
		endIf
        Debug.Trace(msg)
        ; Remove books is now not presented in the menu and is instead tied to "Enable Spell Learning functionality".
        if (currentversion >= 172 && _LEARN_RemoveSpellBooks.GetValue() == 0)
            ; if upgrading from an earlier version and disrupting current settings, let them know what we are changing
            Debug.Notification(__l("notification_update_177_changed", "[Spell Learning] Update has turned back on spell book removal."))
        endIf
        ; Enable both options to ensure they are linked as currently designed.
        _LEARN_RemoveSpellBooks.SetValue(1)
        _LEARN_ResearchSpells.SetValue(1)
    endIf
    if (currentVersion < 176)
        string msg = "[Spell Learning] Installed version 1.7.6"
		if (!displayedUpgradeNotice)
			; don't display multiple upgrade messages
			Debug.Notification(msg)
			displayedUpgradeNotice = true
		endIf
        Debug.Trace(msg)
        updateSpellLearningEffect()
    endIf
    if (currentVersion < 175)
        string msg = "[Spell Learning] Installed version 1.7.5"
		if (!displayedUpgradeNotice)
			; don't display multiple upgrade messages
			Debug.Notification(msg)
			displayedUpgradeNotice = true
		endIf
        Debug.Trace(msg)
        ; Change default notification setting to prepare for better notifications
        VisibleNotifications = new int[16]
        VisibleNotifications[NOTIFICATION_REMOVE_BOOK] = 0 
        VisibleNotifications[NOTIFICATION_ADD_SPELL_NOTE] = 0
        VisibleNotifications[NOTIFICATION_VANILLA_ADD_SPELL] = 0
        VisibleNotifications[NOTIFICATION_ADD_SPELL_LIST] = 1
        VisibleNotifications[NOTIFICATION_ADD_SPELL_LIST_FAIL] = 1
        VisibleNotifications[NOTIFICATION_LEARN_SPELL] = 1
        VisibleNotifications[NOTIFICATION_LEARN_FAIL] = 1
        VisibleNotifications[NOTIFICATION_MOVING_ON] = 1
        VisibleNotifications[NOTIFICATION_DISCOVERY] = 1
        VisibleNotifications[NOTIFICATION_DREADMILK] = 1
        VisibleNotifications[NOTIFICATION_DREAM] = 1
        VisibleNotifications[NOTIFICATION_SPIRIT_TUTOR] = 1
        VisibleNotifications[NOTIFICATION_STUDY] = 1
        VisibleNotifications[NOTIFICATION_TOO_SOON] = 1
        VisibleNotifications[NOTIFICATION_ERROR] = 1
        VisibleNotifications[NOTIFICATION_FORCE_DISPLAY] = 1
    endIf
    if (currentVersion < 174)
		string msg = "[Spell Learning] Installed version 1.7.4"
		if (!displayedUpgradeNotice)
			; don't display multiple upgrade messages
			Debug.Notification(msg)
			displayedUpgradeNotice = true
		endIf
        Debug.Trace(msg)
        ; When upgrading, keep old default note scaling values
        ; These were not previously user-configurable so they need to be specified here
        if (currentVersion == 172)
            _LEARN_maxNotes.SetValue(10000)
            _LEARN_maxNotesBonus.SetValue(10)
        elseif (currentVersion == 173)
            _LEARN_maxNotes.SetValue(1800)
            _LEARN_maxNotesBonus.SetValue(20)
        endIf  
    endIf
	if (currentVersion < 173)
		string msg = "[Spell Learning] Installed version 1.7.3"
		if (!displayedUpgradeNotice)
			; don't display multiple upgrade messages
			Debug.Notification(msg)
			displayedUpgradeNotice = true
		endIf
		Debug.Trace(msg)
		; Set up new list of scaling options
		effortLabels = new String[3]
		effortLabels[0] = "Tough Start"
		effortLabels[1] = "Diminishing Returns"
		effortLabels[2] = "Linear"
		; If user is upgrading from the last version, disable new options even if they are
        ; now enabled by default to not disrupt existing functionality for users.
		; Unfortunately cannot cover older versions because it was 1.7.2 that introduced versioning
		if (currentVersion == 172)
			_LEARN_DynamicDifficulty.SetValue(0)
			_LEARN_IntervalCDREnabled.SetValue(0)
			_LEARN_AutoNoviceLearningEnabled.SetValue(0)
			_LEARN_MaxFailsAutoSucceeds.SetValue(0)
			_LEARN_TooDifficultEnabled.SetValue(0)
		endIf
		; Add study power
		PlayerRef.AddSpell(_LEARN_StudyPower, false)
		; Fix attunement cooldown
		if (GameDaysPassed.GetValue() >= 7)
			_LEARN_LastSetHome.SetValue(GameDaysPassed.GetValue() - 7)
		else
			_LEARN_LastSetHome.SetValue(0)
		endIf
	endIf
    if (currentVersion < 172)
		string msg = "[Spell Learning] Installed version 1.7.2"
		if (!displayedUpgradeNotice)
			; don't display multiple upgrade messages
			Debug.Notification(msg)
			displayedUpgradeNotice = true
		endIf
		Debug.Trace(msg)
    endIf
    currentVersion = GetVersion()
endFunction

function InternalPrepare()
{Maintainence function}
    aSchools[0] = __l("mcm_automatic", "Automatic"); added here for mid-game localization support
    UpgradeVersion()
    ; Populate ObjectReferences with chests containing all spell tomes
    QASpellTomeContainer = Game.GetFormFromFile(0x000C2CD9, "Skyrim.esm") as ObjectReference
    if (QASpellTomeContainer)
        Debug.Trace("[Spell Learning] Got reference to QA container")
    else
        Debug.Trace("[Spell Learning] Cannot reference QA container")
    endIf
    if (_LEARN_DiscoveryChest)
        Debug.Trace("[Spell Learning] DiscoveryChest property populated successfully")
    else
        Debug.Trace("[Spell Learning] Failed to populate DiscoveryChest property")
    endIf
    QASpellTomeContainer.RemoveAllItems(akTransferTo = _LEARN_DiscoveryChest)
    QASpellTomeContainer.Reset()
    ; Odin
    ; Do one and test existence first before populating rest
    ODN_Conjuration_Chest = Game.GetFormFromFile(0x000B57A6, "Odin - Skyrim Magic Overhaul.esp") as ObjectReference
    if (ODN_Conjuration_Chest) ; exists
        Debug.Trace("[Spell Learning] Got reference to Odin container")
        ODN_Conjuration_Chest.RemoveAllItems(akTransferTo = _LEARN_DiscoveryChest)
        ODN_Conjuration_Chest.Reset()
        ODN_Illusion_Chest = Game.GetFormFromFile(0x0023DA83, "Odin - Skyrim Magic Overhaul.esp") as ObjectReference
        ODN_Restoration_Chest = Game.GetFormFromFile(0x002611EE, "Odin - Skyrim Magic Overhaul.esp") as ObjectReference
        ODN_Destruction_Chest = Game.GetFormFromFile(0x0026B454, "Odin - Skyrim Magic Overhaul.esp") as ObjectReference
        ODN_Alteration_Chest = Game.GetFormFromFile(0x00275687, "Odin - Skyrim Magic Overhaul.esp") as ObjectReference
        ODN_Illusion_Chest.RemoveAllItems(akTransferTo = _LEARN_DiscoveryChest)
        ODN_Illusion_Chest.Reset()
        ODN_Restoration_Chest.RemoveAllItems(akTransferTo = _LEARN_DiscoveryChest)
        ODN_Restoration_Chest.Reset()
        ODN_Destruction_Chest.RemoveAllItems(akTransferTo = _LEARN_DiscoveryChest)
        ODN_Destruction_Chest.Reset()
        ODN_Alteration_Chest.RemoveAllItems(akTransferTo = _LEARN_DiscoveryChest)
        ODN_Alteration_Chest.Reset()
    endIf
    ; Apocalypse
    WB_Conjuration_Chest = Game.GetFormFromFile(0x000B57A6, "Apocalypse - Magic of Skyrim.esp") as ObjectReference
    if (WB_Conjuration_Chest) ; exists
        Debug.Trace("[Spell Learning] Got reference to apoc container")
        WB_Conjuration_Chest.RemoveAllItems(akTransferTo = _LEARN_DiscoveryChest)
        WB_Conjuration_Chest.Reset()
        WB_Illusion_Chest = Game.GetFormFromFile(0x000B57A8, "Apocalypse - Magic of Skyrim.esp") as ObjectReference
        WB_Restoration_Chest = Game.GetFormFromFile(0x000B57A9, "Apocalypse - Magic of Skyrim.esp") as ObjectReference
        WB_Destruction_Chest = Game.GetFormFromFile(0x000B57A7, "Apocalypse - Magic of Skyrim.esp") as ObjectReference
        WB_Alteration_Chest = Game.GetFormFromFile(0x000A94A1, "Apocalypse - Magic of Skyrim.esp") as ObjectReference
        WB_Illusion_Chest.RemoveAllItems(akTransferTo = _LEARN_DiscoveryChest)
        WB_Illusion_Chest.Reset()
        WB_Restoration_Chest.RemoveAllItems(akTransferTo = _LEARN_DiscoveryChest)
        WB_Restoration_Chest.Reset()
        WB_Destruction_Chest.RemoveAllItems(akTransferTo = _LEARN_DiscoveryChest)
        WB_Destruction_Chest.Reset()
        WB_Alteration_Chest.RemoveAllItems(akTransferTo = _LEARN_DiscoveryChest)
        WB_Alteration_Chest.Reset()
    endIf
    ; Because this function InternalPrepare() is called on every load, we can refresh our LeveledList changes
    ; since they are not persistent in a save when added via script. This function checks
    ; conditions itself, so we don't need to here.
    SpawnItemsInWorld()    
endFunction

; === Localization
string function __l(string keyName, string defaultValue = "")
    if CanUseLocalizationLib
        return _LEARN_Strings.__l(keyName, defaultValue);
    endIf
    if (defaultValue == "")
        return keyName;
    endIf
    return defaultValue 
endFunction

int function GetMenuLangId()
    if CanUseLocalizationLib
        return _LEARN_Strings.GetMenuLangId()
    else
        return 0
    endIf
endFunction

; === Spell list management
bool function forceLearnSpellAt(int index, bool useVanillaNotification)
    Book spellToLearn = _LEARN_learningList.getAt(index) as Book
    if spellToLearn
        if !alreadyLearned(spellToLearn)
            PlayerRef.EquipItem(spellToLearn, false, false)
            _LEARN_alreadyLearned.addForm(spellToLearn)
            removeTomeFromLists(spellToLearn)
            ; All spell learning in the mod goes through this method so
            ; we can remove the spell learning effect that lets
            ; the player know there are spells to learn here if needed.
            updateSpellLearningEffect()
            ; Give the book back to the player if we are configured to do that.
            if (_LEARN_ReturnTomes.GetValue() == 1)
                returnTomeAndPurge(spellToLearn)                
            endIf
            return true
        endIf
    endIf
    return false
endFunction

; === Mod initialization functions
function SpawnItemsInWorld(); TODO Test.
    if (_LEARN_SpawnItems.GetValue() == 1)
        ; Spirit Tutor tome
        LitemSpellTomes00Conjuration.addform(_LEARN_SpellTomeSummonSpiritTutor, 1, 1)
        ; Attunement tome
        LitemSpellTomes25Alteration.addform(_LEARN_SetHomeSpBook, 1, 1)
        ; Drugs
        LootWarlockRandom.addform(LootLearningDrugs, 1, 1)
        LootRandomBanditWizard.addform(LootLearningDrugs, 1, 1)
        LootForswornRandomWizard.addform(LootLearningDrugs, 1, 1)
        ; Add more spell tome spawns to some mage enemies
        LootWarlockRandom.addform(LootWarlockSpellTomes00All15, 1, 1)
        LootRandomBanditWizard.addform(LootWarlockSpellTomes00All15, 1, 1)
        LootForswornRandomWizard.addform(LootWarlockSpellTomes00All15, 1, 1)
    endIf
    if (_LEARN_EnthirSells.GetValue() == 1)
        ; Re-run each alias's on init script. It will run its own checks and
        ; do what needs to be done
        enthirChestAlias.OnInit()
        ; ForceRefIfEmpty()
        tolfdirChestAlias.OnInit()
    endIf
EndFunction

function RemoveItemsFromWorld()
        ; Remove items from lists. The only clean way of doing this also removes all other
        ; script-added items from these lists. Players are asked to save and reload after disabling
        ; SpawnItems to refresh any changes to these lists from other mods. As a result, we should 
        ; ensure this function is only run when the setting is first disabled, not frequently, 
        ; as this would disrupt other mod scripts that affect these lists.
        ; Currently it is set up to ONLY run from MCMConfigQuest after the player has
        ; clicked the toggle in order to disable the setting.
        ; Why do it this way when it has problems? Well, RemoveAddedForm doesn't seem to be
        ; working and isn't documented on the wiki. An alternative to this is to set each 
        ; item's count to 0, but I have a feeling that will bork the save if players remove the
        ; mod and reload, so let's not do that.
        ;
        ; Spirit Tutor tome
        LitemSpellTomes00Conjuration.Revert()
        ; Attunement tome
        LitemSpellTomes25Alteration.Revert()
        ; Drugs, spell tomes
        LootWarlockRandom.Revert()
        LootRandomBanditWizard.Revert()
        LootForswornRandomWizard.Revert()
        ; Remove items from enthir and tolfdir's inventories
        enthirChestAlias.RemoveItems()
        tolfdirChestAlias.RemoveItems()
endFunction

function OnInit()
   
    aSchools = new String[6]
    aSchools[0] = __l("mcm_automatic", "Automatic")
    aSchools[1] = SPELL_SCHOOL_ALTERATION
    aSchools[2] = SPELL_SCHOOL_CONJURATION
    aSchools[3] = SPELL_SCHOOL_DESTRUCTION
    aSchools[4] = SPELL_SCHOOL_ILLUSION
    aSchools[5] = SPELL_SCHOOL_RESTORATION
    
    aAlterationLL = new LeveledItem[4]
    aAlterationLL[0] = LitemSpellTomes00Alteration
    aAlterationLL[1] = LitemSpellTomes25Alteration
    aAlterationLL[2] = LitemSpellTomes50Alteration
    aAlterationLL[3] = LitemSpellTomes75Alteration
    aConjurationLL = new LeveledItem[4]
    aConjurationLL[0] = LitemSpellTomes00Conjuration
    aConjurationLL[1] = LitemSpellTomes25Conjuration
    aConjurationLL[2] = LitemSpellTomes50Conjuration
    aConjurationLL[3] = LitemSpellTomes75Conjuration
    aDestructionLL = new LeveledItem[4]
    aDestructionLL[0] = LitemSpellTomes00Destruction
    aDestructionLL[1] = LitemSpellTomes25Destruction
    aDestructionLL[2] = LitemSpellTomes50Destruction
    aDestructionLL[3] = LitemSpellTomes75Destruction
    aIllusionLL = new LeveledItem[4]
    aIllusionLL[0] = LitemSpellTomes00Illusion
    aIllusionLL[1] = LitemSpellTomes25Illusion
    aIllusionLL[2] = LitemSpellTomes50Illusion
    aIllusionLL[3] = LitemSpellTomes75Illusion
    aRestorationLL = new LeveledItem[4]
    aRestorationLL[0] = LitemSpellTomes00Restoration
    aRestorationLL[1] = LitemSpellTomes25Restoration
    aRestorationLL[2] = LitemSpellTomes50Restoration
    aRestorationLL[3] = LitemSpellTomes75Restoration

    aInventSpellsPtr = aRestorationLL
    
    RegisterForSleep()
    InternalPrepare()
	
endFunction

; === Chance calculations
float function scaleEffort(float effort, float minchance, float maxchance)
	float scaledEffort
	; This function optionally scales effort to be non-linear. 
	; In the original, an s-curve was used. It has been changed here slightly so that
	; at effort=0 it returns the minimum chance, and at effort=1 (max effort)
	; it returns the maximum chance. Values in between are scaled to 
	; provide a harder start (low total effort is more punished).
	; There are no diminishing returns with effort - above about 60%
	; the relationship between effort in and scaled effort is relatively linear.
    if (_LEARN_EffortScaling.GetValue() == 0) ; If preference set to scurve
		scaledEffort = (minchance + (maxchance - minchance) * (2 - 2 / (1 + (effort*effort*effort))))
	; Alternatively, you can use a square root. This provides the opposite effect.
	; Low effort values are scaled up, while higher values have diminishing returns.
    ElseIf(_LEARN_EffortScaling.GetValue() == 1) ; If preference set to square root
		scaledEffort = ((maxchance - minchance) * Math.sqrt(effort) + minchance)
	; Finally, linear 1:1 is an option. Warning that this often maxes out small discovery
	; chances, as even reaching 5% of the total amount of effort you could generate
	; (which is very easy) will result in a roll of 5%, for example.
    ElseIf(_LEARN_EffortScaling.GetValue() == 2) ; If preference set to linear
		if (effort > maxchance)
			scaledEffort = maxchance
		elseIf (effort < minchance)
			scaledEffort = minchance
		else
			scaledEffort = effort
		endIf
	Else ; This should never happen. But let's at least ensure things are happening if it does.
		return maxchance
	EndIf
    return scaledEffort 
EndFunction

float function getAverageSkill()
    float myskill = 0
    int i = 1
    ; Calculate the mean skill over all magic schools
    while (i <= 5)
        myskill += PlayerRef.GetActorValue(aSchools[i]) / 5
        i += 1
    EndWhile
    return myskill
endFunction

float function getNotesBonus(float notes, bool schoolSpecific)
    ; Amount of spell learning notes in inventory provide bonus (diminishing returns, 
	; up to max of 33% of 33% of final effort).
	; The number of notes possessed by the player is related to the value of the spells they have read.
	; So this value is normalized by comparing the value of a core spellbook 
    ; (in this case Candlelight) to accomodate some mods which alter the spell tome values. 
    ; To be honest I am really unsure if this step is necessary, because the amount of notes spawning
    ; in the player's inventory should already be adjusted in this way. But I suppose it can't hurt,
    ; and surely there is a reason it was originally added, so let's keep it.
    Book refCandleLight = Game.GetForm(0x0009E2A7) as Book
    float priceFactor = refCandleLight.GetGoldValue() / 44
    notes = notes / pricefactor
    float bnot
    ; Since these numbers are now configurable, the defaults are set in the esp.
    ; Initialize
    float maxNotesBonusRaw = 1
    float maxNotesBonusPercent = 1
    float maxNotes = 1
    ; _LEARN_maxNotesBonus is currently a percent. We want it to be on a scale from 1-300.
    ; Keeping with the 2/3 specific school and 1/3 total theme: the study power bonus for all notes
    ; is capped at a default of 50, or a defualt of 1/6 of total final effort, and is only given by the 
    ; study power when it's not used for learning/discovery.
	; Thus a school-specific note bonus will be capped at 100, or 1/3 of the total final effort.
	; Getting the default max value of 100 requires carrying a default of _LEARN_maxNotes (default 750g) worth of notes for the relevant school.
    if (schoolSpecific)
        maxNotesBonusRaw = _LEARN_maxNotesBonus.GetValue()*3
        maxNotes = _LEARN_maxNotes.GetValue()
    else
        maxNotesBonusRaw = _LEARN_maxNotesBonus.GetValue()*3/2
		maxNotes = _LEARN_maxNotes.GetValue()*5
    endIf
    maxNotesBonusPercent = maxNotesBonusRaw/100/3
    ; Used to use square root but was too punishing because reaching 100 required 100*100=10000g
    ; of school specific notes. Let's change power to require 2000g of school specific notes for max bonus of 100.
    ; Now that this amount is configurable, the proper exponent to achieve this  is automatically calculated 
    ; using logarithms based on the player's configuration.
    ; This logarithm function requires some recent version of SKSE, and it's currently undocumented on the Creation Kit wiki.
    ; I'm also not sure if it's natural or base 10 but to be honest I really don't care enough to investigate.
    ;
    ; Testing Notes
    ; After testing, diminishing returns is the only model that really makes the power worth using, so we'll go with just that.
    ; The code for the other scaling methods is below. Linear is OK but the power doesn't feel worth using until you have a lot of notes,
    ; and I haven't set up a way to configure the bonus chance scaling for notes independently from scaling of other effort components - nor am I sure I want to. This was the original
    ; design and it does seem to work fine. The problem is this number was always "double scaled", first through this diminishing returns method here
    ; and then later by the effort scaler using the s-curve (or now another method). Let's not fix what isn't broken.
    ;if (_LEARN_EffortScaling.GetValue() == 0) ; If set to punishing start, s-curve.
        ;float percentMaxNotes = 0
        ;float bnotPercent = 0
        ;percentMaxNotes = notes/maxNotes
        ;bnotPercent = scaleEffort(percentMaxNotes, 0, maxNotesBonusPercent) ; Returns a value from 0 to 1 representing the decimal percentage of the raw bonus we should get
        ;bnot = bnotPercent * maxNotesBonusRaw
    ;if (_LEARN_EffortScaling.GetValue() == 1) ; If diminishing returns scaling method, use x root method with logarithms
        float power = 1
        ; Log is SKSE-dependent
        ;power = 1/(Math.log(maxNotes)/Math.log(maxNotesBonusRaw))
        bnot = Math.pow(notes, (1/2))
    ;if(_LEARN_EffortScaling.GetValue() == 2 || _LEARN_EffortScaling.GetValue() == 0) ; Linear scaling for tough start or linear
    ;    bnot = (notes/maxNotes)*maxNotesBonusRaw
    ;endIf
    ; Cap at max value
    if (bnot > maxNotesBonusRaw)
        bnot = maxNotesBonusRaw
    endIf
    return bnot
endFunction

float function calcEffort(float skill, float casts, float notes)
    float effort
	; result is on a scale of 0-1ish.
	; with enough bonus it can go above 1.
	; it's made of three things:
	; myskill (considering magic skill levels)
	; mycasts (spell casts of same school)
	; mybonus (other roleplaying bonus)

	; calculate myskill
    float myskill = 0 ; out of 100
    myskill = getAverageSkill()
    ; That will count for 1/3rd
    myskill /= 3
    ; specific magic school skill (passed in) will count for 2/3rds
    myskill += skill * 2 / 3

	; cap the passed mycasts at 100 casts.
    float mycasts = casts ; maximum 100
    if (mycasts > 100)
        mycasts = 100
    endif
 
    ; calculate mybonus
    float mybonus = 0 ; no cap. enough bonus can make up for lacking in other two.
	; the CountBonus variable is accessed by other scripts to add more to the bonus.
	; For example, the removed dialogue option used this variable.
	; The random "dream" bonus/penalty, the Daedric Tutor, and the study power bonus use this value.
    mybonus += _LEARN_CountBonus.GetValue()
    mybonus += getNotesBonus(notes, true)
    ; Check for drug bonus
    if (PlayerRef.HasMagicEffect(AlchDreadmilkEffect)) ; dreadmilk
        mybonus += 300 ; Dreadmilk gives automatic max total effort, and therefore automatic max roll.
    elseif (PlayerRef.HasMagicEffect(AlchShadowmilkEffect)) ; shadowmilk
        mybonus += 60 ; Shadowmilk provides 20% of total effort all by itself. This can help bypass the "tough start" hump.
    endif
    ; Check for good location
    Location currentLocation = PlayerRef.GetCurrentLocation()
    if (currentLocation)
        if (currentLocation.HasKeyword(LocTypeTemple) || currentLocation.HasKeyword(LocTypePlayerHouse) || currentLocation.isSameLocation(customLocation))
            mybonus += 22
        elseIf (currentLocation.isSameLocation(WinterholdCollegeLocation) || WinterholdCollegeLocation.isChild(currentLocation))
            mybonus += 33
		elseIf (currentLocation.HasKeyword(LocTypeInn))
			mybonus += 11
        endif
    endIf
    ; Failing to learn also counts as progress for rng roll, 
    ; but only if some role playing is already happening
    if (mybonus >= 33)
        mybonus += iFailuresToLearn * 11
    endif
	; scale mybonus using the configurable BonusScale parameter (default 1, max 3)
    mybonus = mybonus * _LEARN_BonusScale.GetValue()
	
    effort = ((myskill + mycasts + mybonus) / 3 / 100)
	; cap effort at 1
	; this ensures the bonus value can only make up for lost effort from myskill and mycast.
	; gives cleaner math for scaling, as effort scales exactly from 0 to 1.
    if (effort < 0)
        effort = 0
	ElseIf (effort > 1)
		effort = 1
    EndIf
    return effort
EndFunction

float function calcCDReffort()
	float mycasts = getTotalCasts()
	; mycasts max of 500 - 100 of each school counted.
	; we will cap it at 100 because 500 spell casts per rest is not realistic?
	if (mycasts > 100)
		mycasts = 100
	endIf
	; weighting is here and not configurable atm.
	return ((mycasts)/100) 
endFunction

float function baseChance(float minchance, float maxchance)
    float fskill = getAverageSkill()
    float fcasts = _LEARN_CountRestoration.GetValue()
    float fnotes = PlayerRef.GetItemCount(_LEARN_SpellNotesGeneric)
    ; Get the chance from effort calculations, scaling as configured.
    float fChance = scaleEffort(calcEffort(fskill, fcasts, fnotes), minchance / 100, maxchance / 100)
	; Check to see if dynamic difficulty is enabled.
    ; If it is, then adjust the returned chance accordingly to make it more/less likely to learn the spell.
    ; This only applies to spell learning, not discovery, so a passed bool lets us disable it.
    return fChance
EndFunction

float function getTotalCasts()
	return _LEARN_CountRestoration.GetValue()
endFunction

float function getTotalNotes()
	return PlayerRef.GetItemCount(_LEARN_SpellNotesGeneric)
endFunction

; === Time management
float Function hours_before_next_ok_to_learn()
    float now = GameDaysPassed.GetValue()
	float nextOK = LastLearnTime + 1
	; If cooldown reduction is enabled, then reduce the required wait time accordingly.
	if (_LEARN_IntervalCDREnabled.GetValue() == 1)
		float actualCDR = 0
		actualCDR = scaleEffort(calcCDReffort(), 0, (_LEARN_IntervalCDR.GetValue() / 100))
		nextOK = LastLearnTime + _LEARN_StudyInterval.GetValue()*(1-actualCDR)
	Else
		nextOK = LastLearnTime + _LEARN_StudyInterval.GetValue() ; default is 0.65
	EndIf

    if now >= nextOK
        return 0
    Else
        return ((nextOK - now) * 24)
    endif
EndFunction

float Function hours_before_next_ok_to_discover()
    float now = GameDaysPassed.GetValue()
	float nextOK = LastDiscoverTime + 1
	; If cooldown reduction is enabled, then reduce the required wait time accordingly.
	if (_LEARN_IntervalCDREnabled.GetValue() == 1)
		float actualCDR = 0
		actualCDR = scaleEffort(calcCDReffort(), 0, (_LEARN_IntervalCDR.GetValue() / 100))
		nextOK = LastDiscoverTime + _LEARN_StudyInterval.GetValue()*(1-actualCDR)
	Else
		nextOK = LastDiscoverTime + _LEARN_StudyInterval.GetValue() ; default is 0.65
	EndIf

    if now >= nextOK
        return 0
    Else
        return ((nextOK - now) * 24)
    endif
EndFunction

float function hours_before_next_ok_to_sleep()
    float now = GameDaysPassed.GetValue()
    float nextOK = LastSleepTime + 1
    nextOK = LastSleepTime + _LEARN_StudyInterval.GetValue()
    if now >= nextOK
        return 0
    Else
        return ((nextOK - now) * 24)
    endif
endFunction

; === Learning and discovery helper functions
function tryLearnSpell(int fifoIndex, bool forceSuccess)
	; if passed bool forceSuccess is true, just succeed
	if (forceSuccess)
		notify(__l("notification_effortless_learn", "This spell came effortlessly to you."), NOTIFICATION_LEARN_SPELL)
		forceLearnSpellAt(fifoindex, (VisibleNotifications[NOTIFICATION_VANILLA_ADD_SPELL]))
		iFailuresToLearn = 0
		return
	EndIf
	
	; Otherwise, roll to learn the spell
	if ((rollToLearn(baseChance(_LEARN_MinChanceStudy.GetValue(), _LEARN_MaxChanceStudy.GetValue())))) 
		notify(__l("notification_learn_spell", "It all makes sense now!"), NOTIFICATION_LEARN_SPELL)
		forceLearnSpellAt(fifoindex, (VisibleNotifications[NOTIFICATION_VANILLA_ADD_SPELL]))
		iFailuresToLearn = 0 
	Else 
        iFailuresToLearn = iFailuresToLearn + 1
        ; TODO decide to keep this notification or not for non-SKSE version, can be somewhat confusing
        notify(__l("notification_fail_spell", "This spell still makes no sense..."), NOTIFICATION_LEARN_FAIL)
	EndIf
EndFunction

bool function rollToLearn(float fChance)
	Float fRand
	; ...check to see if HarderParallel is enabled. If it is, divide chance by number of spells being learned.
	if (_LEARN_HarderParallel.GetValue() != 0) 
		fRand = Utility.RandomFloat(0.0, 1.0)
		fRand = fRand * _LEARN_ParallelLearning.GetValue()
	Else ; Otherwise, roll as normal.
		fRand = Utility.RandomFloat(0.0, 1.0)
	EndIf
	
	; Once you have the roll, compare it to the chance. If it passes, return a True boolean.
	if (fRand < fChance)
		return True
	Else
		return False
	EndIf
EndFunction

function MoveSpellToBottom(int index)
    Book toMove = _LEARN_learningList.GetAt(index) as Book
    _LEARN_learningList.RemoveAddedForm(toMove)
    _LEARN_learningList.AddForm(toMove)
endFunction

function doLearning()
	int alreadyLearnedSpells = 0
    ; The main "spell learning" function. Goes through the list according to the player's settings
    ; and attempts to learn new spells.
  
    ; Before the main spell learning cycle, if we've reached the max amount of failures, we'll handle that here first.
	; As long as the setting is enabled, obviously.
	if (iFailuresToLearn >= _LEARN_MaxFailsBeforeCycle.GetValue() && _LEARN_MaxFailsBeforeCycle.GetValue() != 0)
		if (_LEARN_MaxFailsAutoSucceeds.GetValue() == 1)
		; If reaching the max amount of fails is supposed to make you auto succeed and it's not an automatic failure for some other reason...
            ; ...then automatically learn the spell.
            notify(__l("notification_fail_upwards_no_skse", "It's finally coming together!"), NOTIFICATION_LEARN_SPELL)
			forceLearnSpellAt(0, (VisibleNotifications[NOTIFICATION_VANILLA_ADD_SPELL]))
			iFailuresToLearn = 0
			alreadyLearnedSpells = alreadyLearnedSpells + 1
		else ; Otherwise it's supposed to just move the spell to the bottom of the list.
			MoveSpellToBottom(0)
			iFailuresToLearn = 0
            notify(__l("notification_moving_on_no_skse", "Not making any progress on this one... trying other spells."), NOTIFICATION_MOVING_ON)
		endIf
	endIf
	
	; main spell learning loop
	if (true)
		; initialize variables only used in this loop
		int currentSpell = 0
		float spellLimit = 1
		; set the spell limit
		if (_LEARN_AutoSuccessBypassesLimit.GetValue() == 1 && _LEARN_MaxFailsAutoSucceeds.GetValue() == 0)
			; if all the ways spells could be learned before are off or are set
			; to not count towards the limit, then the limit is just the amount of spells per
			; day to learn
			spellLimit = _LEARN_ParallelLearning.GetValue()
		else
			; otherwise, subtract the already learned spells counter from the amount of available spells to learn
			spellLimit = _LEARN_ParallelLearning.GetValue()-alreadyLearnedSpells
		endIf
		; while below max daily limit AND not yet at end of list, iterate through and try to learn
		while (currentSpell < spellLimit && currentSpell < _LEARN_learningList.getSize()) 
            ; try to learn
            tryLearnSpell(currentSpell, false)
            ; increment counter
			currentSpell = currentSpell + 1
		endWhile
    endIf

    ; Reset learning timer
    LastLearnTime = GameDaysPassed.GetValue()

endFunction

int function pickSchool()
    ; Choose a spell school to discover from randomly. Chance is weighed towards schools
    ; the player is more skilled in.
    int totalSkill = 0
    int[] schoolSkill = new int[6]
    float[] schoolPercent = new float[6]
    ; Calculate the mean skill over all magic schools
    ;aSchools[1] = SPELL_SCHOOL_ALTERATION
    ;aSchools[2] = SPELL_SCHOOL_CONJURATION
    ;aSchools[3] = SPELL_SCHOOL_DESTRUCTION
    ;aSchools[4] = SPELL_SCHOOL_ILLUSION
    ;aSchools[5] = SPELL_SCHOOL_RESTORATION
    int outerCount = 1
    while (outerCount <= 5)
        totalSkill += PlayerRef.GetActorValue(aSchools[outerCount]) as int
        schoolSkill[outerCount] = PlayerRef.GetActorValue(aSchools[outerCount]) as int
        outerCount += 1
    EndWhile
    ; Get percentage of all magickal skill related to each school
    outerCount = 1
    schoolPercent[0] = 0
    while (outerCount <= 5)
        schoolPercent[outerCount] = (schoolSkill[outerCount] as float/totalSkill as float)
        outerCount += 1
    EndWhile
    ; Successively add previous percentages to distribute results from 0-1
    outerCount = 5
    int innerCount = 4
    while (outerCount >= 1)
        float lowerTotal = 0
        while (innerCount >= 1)
            lowerTotal += schoolPercent[innerCount]
            innerCount -= 1
        endWhile
        schoolPercent[outerCount] = schoolPercent[outerCount] + lowerTotal as float
        outerCount -= 1
        innerCount = outerCount - 1
    EndWhile
    float fRand = Utility.RandomFloat(0.0, 1.0)
    outerCount = 1
    while (outerCount <= 5)
        if (fRand < schoolPercent[outerCount])
            ; Then this is the chosen school.
            if (outerCount == 1) ; Alteration
                aInventSpellsPtr = aAlterationLL
            elseIf (outerCount == 2) ; Conjuration
                aInventSpellsPtr = aConjurationLL
            elseIf (outerCount == 3) ; Destruction
                aInventSpellsPtr = aDestructionLL
            elseIf (outerCount == 4) ; Illusion
                aInventSpellsPtr = aIllusionLL
            elseIf (outerCount == 5) ; Restoration
                aInventSpellsPtr = aRestorationLL
            endIf
            ; return result if we need it for some reason
            return outerCount
        endIf
    endWhile
    ; Things should not get here. Set and return resto and print an error.
    aInventSpellsPtr = aRestorationLL
    notify(__l("notification_error_schoolPick", "[Spell Learning] Error selecting school. Defaulting to Restoration."), NOTIFICATION_ERROR)
    return 5
endFunction

Spell function doDiscovery()
    ; The main "Spell Discovery" function.
    float fSkill = getAverageSkill()
    float baseChance = baseChance(_LEARN_MinChanceDiscover.GetValue(), _LEARN_MaxChanceDiscover.GetValue())
    float fRand = Utility.RandomFloat(0.0, 1.0) 
    if (fRand > baseChance) 
        ; Reset discovery timer
        LastDiscoverTime = GameDaysPassed.GetValue()
        ; Spell discovery failure ! 
        Return None
    EndIf
    
    int llidx
    if (fskill < 25)
        llidx = 0
    elseif (fskill < 50)
        llidx = 1
    elseif (fskill < 75)
        llidx = 2
    Else
        llidx = 3
    EndIf
    ; Update the Spells "ptr" to pick a school
    pickSchool()
    ; === TODO
    ;;;; Then get a random item from the
    int llcount = _LEARN_discoveryPossibilities.getSize()
    int spidx = Utility.RandomInt(0, llcount - 1)
    Book inventedBook = _LEARN_discoveryPossibilities.GetAt(spidx) as Book
    int limit = 10
    while ((alreadyLearned(inventedBook) || _LEARN_learningList.Find(inventedBook) != -1) && limit > 0)
        spidx = (spidx + 1) % llcount
        inventedBook = _LEARN_discoveryPossibilities.GetAt(spidx) as Book
        limit -=1
    EndWhile
    
    if (! (alreadyLearned(inventedBook) || _LEARN_learningList.Find(inventedBook) != -1))
        notify(__l("notification_new_spell_idea", "An idea for a new spell is coming to you..."), NOTIFICATION_DISCOVERY)
        ; If spell learning is enabled, add the discovered spell to the list.
        ; If spell learning is disabled, instantly learn the discovered spell.
        if (_LEARN_ResearchSpells.GetValue())
            _LEARN_learningList.AddForm(inventedBook)
            updateSpellLearningEffect()
        else
            PlayerRef.EquipItem(inventedBook, false, false)
            _LEARN_alreadyLearned.AddForm(inventedBook)
        endIf
    EndIf
    
    ; Reset discovery timer
    LastDiscoverTime = GameDaysPassed.GetValue()

EndFunction

function doDream()
    float fRand = 1
    fRand = Utility.RandomFloat(0.0, 1.0)
    if (fRand < 0.01)
        notify(__l("notification_dreamt_Julianos", "You dreamt that Julianos was watching over you."), NOTIFICATION_DREAM)
        _LEARN_CountBonus.SetValue(100)
    ElseIf (fRand < 0.02)
        notify(__l("notification_dreamt_flying", "You dreamt that you were flying over Solstheim."), NOTIFICATION_DREAM)
        _LEARN_CountBonus.SetValue(30)
    ElseIf (fRand < 0.03)
        notify(__l("notification_dreamt_exam", "You had a nightmare about being lost forever in a plane of Oblivion."), NOTIFICATION_DREAM)
        _LEARN_CountBonus.SetValue(-40)
    endif
endFunction

function doReset()
    ; reset counters and limits for the cycle
    ; These are bonuses only that get reset here. 
    ; Any negative effects that tick down are tied to the sleep cooldown.
    _LEARN_CountAlteration.SetValue(0.0)
    _LEARN_CountConjuration.SetValue(0.0)
    _LEARN_CountDestruction.SetValue(0.0)
    _LEARN_CountIllusion.SetValue(0.0)
    _LEARN_CountRestoration.SetValue(0.0)
    _LEARN_CountBonus.SetValue(0.0)
    _LEARN_AlreadyUsedTutor.SetValue(0)
    _LEARN_LastDayStudied.SetValue(0)
    ; this function checks to see if the proper config setting is enabled so we don't need to here
    ; the purpose of having this here is if a player turns on the setting mid-play,
    ; otherwise it wouldn't be refreshed until the next load game.
    ; checks in the function ensure everything is only added once, so it does no harm.
    SpawnItemsInWorld() 
endFunction

function updateSpellLearningEffect()
    if (_LEARN_learningList.GetSize() == 0 && (PlayerRef.hasSpell(_LEARN_SpellsToLearn)))
        ; If there are no more spells to learn and the player has the effect, remove it.
        PlayerRef.removeSpell(_LEARN_SpellsToLearn)
    elseIf (_LEARN_learningList.GetSize() != 0 && !(PlayerRef.hasSpell(_LEARN_SpellsToLearn)))
        ; If there are spells to learn and the player doesn't have the effect, add it silently.
        PlayerRef.addSpell(_LEARN_SpellsToLearn, false)
    endIf
endFunction

; === Tracked player events
Event OnSleepStop(Bool abInterrupted)
	
	; Test conditions for doing absolutely nothing
    if (abInterrupted)
        ; If sleep was interrupted. 
        notify(__l("notification_sleep_interrupted", "Your sleep was interrupted."), NOTIFICATION_FORCE_DISPLAY)
        return
    endIf

    ; If we pass the checks and they are enabled and off cooldown, then do the things.
    ; In the case that anything fails, check to see if we've already sent a notification, and if we have, don't send another.
    if (_LEARN_LearnOnSleep.GetValue() == 1 && hours_before_next_ok_to_learn() <= 0 && _LEARN_learningList.GetSize() != 0)
        ; This only runs and resets the learning cooldown if there's actually something to learn.
        doLearning()
    elseIf (_LEARN_LearnOnSleep.GetValue() == 1 && hours_before_next_ok_to_learn() > 0)
        ; This is really the only mandatory "nothing happened" style notification so most other things have been removed
        notify(__l("notification_slept_too_soon", "Your mind isn't settled enough yet to learn any spells..."), NOTIFICATION_TOO_SOON)
    endIf
    if (_LEARN_DiscoverOnSleep.GetValue() == 1 && hours_before_next_ok_to_discover() <= 0)
        doDiscovery()
    endIf

    ; All the functionality tied to a sleep-specific cooldown
    if (hours_before_next_ok_to_sleep() <= 0)
        ; Chance to heal Dreadstare disease
        if (PlayerRef.HasSpell(_LEARN_DiseaseDreadmilk))
            float fRand = 0
            fRand = Utility.RandomFloat(0.0, 1.0)
            if (fRand > (0.2 - 0.1*_LEARN_consecutiveDreadmilk.GetValue()))
                notify(__l("notification_no_more_dreadmilk_addiction", "You're finally starting to feel your dreadmilk craving wane."), NOTIFICATION_DREADMILK)
                PlayerRef.RemoveSpell(_LEARN_DiseaseDreadmilk)
            endif
        endif
        
        ; Reduce blood toxicity
        if (_LEARN_consecutiveDreadmilk.GetValue() > 0)
            _LEARN_consecutiveDreadmilk.Mod(-1)
            if (_LEARN_consecutiveDreadmilk.GetValue() <= 0 && !PlayerRef.HasMagicEffect(AlchDreadmilkEffect))
                _LEARN_consecutiveDreadmilk.SetValue(0)
                notify(__l("notification_dreadmilk_out_of_system", "All the Dreadmilk is finally out of your system..."), NOTIFICATION_DREADMILK)
                if (PlayerRef.HasSpell(_LEARN_DiseaseDreadmilk))
                    PlayerRef.RemoveSpell(_LEARN_DiseaseDreadmilk)
                endIf
            endIf
        endIf

        ; Reset sleep cooldown and once-per-cycle bonuses
        LastSleepTime = GameDaysPassed.GetValue()
        doReset()

        ; Dreams after we reset the bonus
        doDream()
    endIf

EndEvent




